import pandas as pd
from datetime import datetime

# M√©tricas B√°sicas de Ventas
print("\n" + "="*50)
print("üìä M√âTRICAS CLAVE DE VENTAS".center(50))
print("="*50)
print(f"üí∞ Ventas Totales: ${df['total'].sum():,.2f}")
print(f"üõí Transacciones Totales: {len(df):,}")
print(f"üì¶ Unidades Vendidas: {df['quantity'].sum():,}")
print(f"üè∑Ô∏è Ticket Promedio: ${df['total'].mean():,.2f}")
print(f"üìà Venta M√°xima: ${df['total'].max():,.2f} (ID: {df.loc[df['total'].idxmax(), 'invoice_id']})")

# M√©tricas de Rentabilidad
print("\n" + "="*50)
print("üíµ M√âTRICAS DE RENTABILIDAD".center(50))
print("="*50)
print(f"üìâ Costo de Ventas: ${df['cogs'].sum():,.2f}")
print(f"üîº Margen Bruto Total: ${df['gross_income'].sum():,.2f}")
print(f"üìä Margen Bruto %: {df['gross_income'].sum()/df['total'].sum()*100:.2f}%")
print(f"üìå Margen Promedio por Transacci√≥n: ${df['gross_income'].mean():,.2f}")

# M√©tricas Temporales
print("\n" + "="*50)
print("‚è≥ M√âTRICAS TEMPORALES".center(50))
print("="*50)
date_range = df['datetime'].max() - df['datetime'].min()
print(f"üï∞Ô∏è Per√≠odo Analizado: {df['datetime'].min().strftime('%d/%m/%Y')} - {df['datetime'].max().strftime('%d/%m/%Y')} ({date_range.days} d√≠as)")
print(f"‚è±Ô∏è Transacciones/D√≠a: {len(df)/date_range.days:,.1f}")
print(f"üïí Hora Pico: {df['datetime'].dt.hour.mode()[0]}:00 - {df['datetime'].dt.hour.mode()[0]+1}:00")

# M√©tricas por Sucursal
print("\n" + "="*50)
print("üè™ DESEMPE√ëO POR SUCURSAL".center(50))
print("="*50)
branch_stats = df.groupby('branch').agg({
    'total': ['sum', 'mean', 'count'],
    'gross_income': 'mean'
})
branch_stats.columns = ['Ventas Totales', 'Ticket Promedio', 'Transacciones', 'Margen Promedio']
print(branch_stats.sort_values('Ventas Totales', ascending=False).to_string(formatters={
    'Ventas Totales': '${:,.2f}'.format,
    'Ticket Promedio': '${:,.2f}'.format,
    'Margen Promedio': '${:,.2f}'.format
}))

# M√©tricas por L√≠nea de Producto
print("\n" + "="*50)
print("üõçÔ∏è DESEMPE√ëO POR CATEGOR√çA".center(50))
print("="*50)
product_stats = df.groupby('product_line').agg({
    'total': ['sum', 'mean'],
    'quantity': 'sum',
    'gross_income': 'sum'
})
product_stats.columns = ['Ventas Totales', 'Ticket Promedio', 'Unidades', 'Margen Bruto']
print(product_stats.sort_values('Ventas Totales', ascending=False).to_string(formatters={
    'Ventas Totales': '${:,.2f}'.format,
    'Ticket Promedio': '${:,.2f}'.format,
    'Margen Bruto': '${:,.2f}'.format
}))

# Eficiencia Operativa
print("\n" + "="*50)
print("‚öôÔ∏è EFICIENCIA OPERATIVA".center(50))
print("="*50)
payment_stats = df['payment_method'].value_counts(normalize=True)*100
print("üí≥ Mix de M√©todos de Pago:")
print(payment_stats.to_string(header=False, formatters={'': '{:.1f}%'.format}))
print(f"\nüë• Mix de Clientes: Miembros {df['customer_type'].value_counts(normalize=True)['Member']*100:.1f}%")











# Eficiencia Operativa
print("\n" + "="*50)
print("‚öôÔ∏è EFICIENCIA OPERATIVA".center(50))
print("="*50)

# M√©todos de Pago (con protecci√≥n si hay valores nulos)
payment_stats = df['payment_method'].value_counts(normalize=True).mul(100).round(1)
print("\nüí≥ Distribuci√≥n de M√©todos de Pago:")
for method, percent in payment_stats.items():
    print(f"  ‚Ä¢ {method.ljust(12)}: {percent:.1f}%")

# Mix de Clientes (con verificaci√≥n de clave)
customer_mix = df['customer_type'].value_counts(normalize=True).mul(100)
member_percent = customer_mix.get('Member', 0)  # Evita KeyError si no hay 'Member'
non_member_percent = customer_mix.get('Normal', 0)
print(f"\nüë• Mix de Clientes:")
print(f"  ‚Ä¢ Miembros    : {member_percent:.1f}%")
print(f"  ‚Ä¢ No miembros : {non_member_percent:.1f}%")

# Tasa de transacciones por hora pico (valor adicional)
peak_hour = df['datetime'].dt.hour.mode()[0]
transactions_peak = df[df['datetime'].dt.hour == peak_hour].shape[0]
print(f"\n‚è±Ô∏è Hora Pico: {peak_hart}:00 ({transactions_peak} transacciones)")



# Eficiencia Operativa
print("\n" + "="*50)
print("‚öôÔ∏è EFICIENCIA OPERATIVA".center(50))
print("="*50)

# M√©todos de Pago (versi√≥n corregida)
payment_stats = df['payment_method'].value_counts(normalize=True) * 100
print("üí≥ Mix de M√©todos de Pago:")
print(payment_stats.round(1).astype(str) + '%')  # Formato directo sin 'formatters'

# Mix de Clientes (versi√≥n corregida)
customer_mix = df['customer_type'].value_counts(normalize=True) * 100
print(f"\nüë• Mix de Clientes: Miembros {customer_mix.get('Member', 0):.1f}%")



print("üí≥ Mix de M√©todos de Pago:")
print("----------------------------")
for method, percent in payment_stats.round(1).items():
    print(f"{method.ljust(12)}: {percent}%")



# Convertir a DataFrame temporal
payment_df = payment_stats.reset_index()
payment_df.columns = ['M√©todo', 'Porcentaje']
print(payment_df.to_string(formatters={'Porcentaje': '{:.1f}%'.format}, index=False))



'''
# Agregar porcentajes a la consulta
SELECT 
    "Customer type" AS tipo_cliente,
    Gender AS genero,
    SUM(Total) AS ventas_totales,
    SUM(Total) * 100.0 / (SELECT SUM(Total) FROM '../data/supermarket_sales.csv') AS porcentaje
FROM '../data/supermarket_sales.csv'
GROUP BY "Customer type", Gender
'''


# Pandas
ventas_tipo_genero = df.groupby(['customer_type', 'gender'])['total'].sum().unstack()
fig_tipo_genero = px.bar(ventas_tipo_genero, title='Ventas por Tipo de Cliente y G√©nero', barmode='group')
fig_tipo_genero.show()


import duckdb
import plotly.express as px

# DuckDB
query = """
SELECT 
    customer_type,
    gender,
    SUM(total) AS ventas_totales
FROM df  # DuckDB puede leer directamente DataFrames de Pandas
GROUP BY customer_type, gender
"""

# Ejecutar y dar formato id√©ntico al de Pandas
ventas_tipo_genero = con.execute(query).fetchdf().pivot(
    index='customer_type',
    columns='gender',
    values='ventas_totales'
)

# Gr√°fico id√©ntico al original
fig_tipo_genero = px.bar(
    ventas_tipo_genero, 
    title='Ventas por Tipo de Cliente y G√©nero',
    barmode='group'
)
fig_tipo_genero.show()




query = """
SELECT 
    customer_type,
    SUM(CASE WHEN gender = 'Male' THEN total ELSE 0 END) AS Male,
    SUM(CASE WHEN gender = 'Female' THEN total ELSE 0 END) AS Female
FROM df
GROUP BY customer_type
"""
ventas_tipo_genero = con.execute(query).fetchdf()




# Cuando el CSV es grande (>100MB)
query = """
SELECT * 
FROM '../data/supermarket_sales.csv'
LIMIT 5  # Ejemplo: preview r√°pido sin cargar todo en Pandas
"""
con.execute(query).fetchdf()


# Cuando ya tienes un DataFrame peque√±o/mediano
df = pd.read_csv('../data/supermarket_sales.csv', nrows=1000)  # Ejemplo: carga parcial

query = """
SELECT 
    customer_type,
    AVG(total) as avg_spent
FROM df
GROUP BY customer_type
"""
con.execute(query).fetchdf()


Recomendaci√≥n para Jupyter Notebook:
Escenario	Mejor Opci√≥n
Datos grandes (>100MB)	FROM 'archivo.csv'
Datos peque√±os (<100MB)	FROM df
Ya tienes el DataFrame en memoria	FROM df
Quieres evitar cargar todo en RAM	FROM 'archivo.csv'
Trabajas en Colab/Kaggle	FROM df


# Carga inicial con DuckDB (eficiente)
query = """
SELECT *
FROM '../data/supermarket_sales.csv'
WHERE Branch = 'A'  # Filtro temprano
"""
df_filtrado = con.execute(query).fetchdf()

# An√°lisis posterior con Pandas+DuckDB
ventas = con.execute("""
    SELECT gender, SUM(total) 
    FROM df_filtrado 
    GROUP BY gender
""").fetchdf()


# Celda 1: Configuraci√≥n
DUCKDB_PATH = '../data/supermarket_sales.csv'  # Facilita cambios

# Celda 2: Consulta
query = f"""
SELECT *
FROM '{DUCKDB_PATH}'
"""





import pandas as pd

# Cargar datos
df = pd.read_csv('supermarket_sales.csv')

# Convertir a datetime (mm/dd/yyyy)
df['fecha_hora'] = pd.to_datetime(
    df['date'] + ' ' + df['time'],
    format='%m/%d/%Y %H:%M'
)

# Extraer componentes
df['dia'] = df['fecha_hora'].dt.day
df['mes'] = df['fecha_hora'].dt.month
df['a√±o'] = df['fecha_hora'].dt.year

print(df[['date', 'time', 'fecha_hora']].head())






# Orden personalizado de d√≠as
dias_orden = ['Dom', 'Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b']

# Convertir a Categorical para mantener el orden
sales_heatmap['dia_semana'] = pd.Categorical(
    sales_heatmap['dia_semana'],
    categories=dias_orden,
    ordered=True
)

# Pivotear asegurando el orden
heatmap_data = sales_heatmap.pivot(
    index="dia_semana", 
    columns="hora", 
    values="ventas"
).sort_index(level='dia_semana')

# Configuraci√≥n visual
plt.figure(figsize=(14, 8))
sns.set(font_scale=1.1)

# Heatmap profesional
ax = sns.heatmap(
    heatmap_data,
    cmap='YlGnBu',
    annot=True,
    fmt='.0f',
    linewidths=0.5,
    linecolor='white',
    cbar_kws={'label': 'Ventas ($)', 'shrink': 0.8},
    annot_kws={'size': 9}
)

# Personalizaci√≥n
plt.title('Patr√≥n de Ventas: Hora vs D√≠a de la Semana', pad=20, fontsize=14)
plt.xlabel('Hora del D√≠a', labelpad=10)
plt.ylabel('D√≠a de la Semana', labelpad=10)

# Ajustar ticks de horas
#hour_ticks = range(0, 24, 2)  # Mostrar horas pares
#plt.xticks(ticks=[h+0.5 for h in hour_ticks], labels=hour_ticks)

# Resaltar franjas horarias clave
ax.add_patch(plt.Rectangle((8.5, 0), width=3, height=7, fill=False, edgecolor='red', lw=2, clip_on=False))
ax.text(10, -0.5, 'Horario Comercial', ha='center', va='center', color='red')

plt.tight_layout()
plt.show()

















```markdown
# An√°lisis de Ventas - Supermarket Sales

## 1. Configuraci√≥n Inicial
```python
# Librer√≠as
import pandas as pd
import duckdb
import seaborn as sns
import matplotlib.pyplot as plt

# Configuraci√≥n visual
plt.style.use('seaborn')
```

## 2. Carga de Datos
```python
# Opci√≥n 1: Desde pandas
df = pd.read_csv('../data/supermarket_sales.csv')

# Opci√≥n 2: Desde DuckDB
con = duckdb.connect()  # Conexi√≥n en memoria
```

## 3. An√°lisis Exploratorio

### 3.1. Ventas por Hora/D√≠a
```python
# Heatmap de ventas por hora y d√≠a
```

### 3.2. Patrones por G√©nero
```python
# Productos preferidos por g√©nero
# M√©todos de pago por g√©nero
```

## 4. An√°lisis por Segmentos

### 4.1. Tipo de Cliente (Member/Normal)
```python
# Comparaci√≥n de tickets promedio
# Frecuencia de compras
```

### 4.2. Rating de Estratificaci√≥n
```python
# Correlaci√≥n con fecha y ticket
```

## 5. An√°lisis de Productos

### 5.1. Margen Bruto
```python
# Productos con mayor margen
# Identificaci√≥n de outliers
```

### 5.2. An√°lisis de Canasta
```python
# Combinaciones frecuentes
```

## 6. Hip√≥tesis Estad√≠sticas
```python
# Test t-Student: Members vs Normals
# Chi-cuadrado: G√©nero vs M√©todo de pago
```

## 7. Exportaci√≥n de Resultados
```python
# Guardar tablas/gr√°ficos relevantes
```
```












```markdown
# üìä An√°lisis de Ventas - Supermarket Sales

## 1. üîß Configuraci√≥n Inicial
```python
# Importar librer√≠as y conexi√≥n DuckDB
```

## 2. üóÉÔ∏è Carga y Preparaci√≥n de Datos
```python
# Desde CSV a Pandas/DuckDB
```

## 3. üïí An√°lisis Temporales

### 3.1. Ventas por Hora del D√≠a
```python
# Picos horarios y relaci√≥n con tipo de cliente/g√©nero
```

### 3.2. Ventas por D√≠a de la Semana
```python
# Heatmap d√≠a vs hora
# Evoluci√≥n semanal
```

### 3.3. Cohortes (Retenci√≥n)
```python
# An√°lisis de retenci√≥n por mes
```

## 4. üë• Segmentaci√≥n de Clientes

### 4.1. Tipo de Cliente (Member/Normal)
```python
# Ticket promedio y frecuencia
```

### 4.2. G√©nero
```python
# Preferencias de producto y pago
```

### 4.3. Rating de Estratificaci√≥n
```python
# Correlaci√≥n con comportamiento
```

## 5. üè∑Ô∏è An√°lisis de Productos

### 5.1. Margen Bruto
```python
# Productos m√°s rentables
```

### 5.2. Market Basket Analysis
```python
# Combinaciones frecuentes
```

## 6. üè™ An√°lisis por Sucursal

### 6.1. Comparativo Branch/City
```python
# M√©tricas clave por ubicaci√≥n
```

## 7. üîç Validaci√≥n de Hip√≥tesis

### 7.1. Members vs Normals
```python
# Test t-Student
```

### 7.2. G√©nero vs Payment
```python
# Test Chi-cuadrado
```

## 8. üíæ Exportaci√≥n de Resultados
```python
# Gr√°ficos y tablas clave
```
```








```markdown
# üõí Supermarket Sales - An√°lisis Integral

## 1. ‚öôÔ∏è Configuraci√≥n
```python
# Librer√≠as (pandas, duckdb, seaborn, matplotlib)
# Conexi√≥n DuckDB 
# Par√°metros visuales
```

## 2. üìÇ Carga y Preprocesamiento
```python
# Carga desde CSV (Pandas/DuckDB)
# Limpieza b√°sica (missings, duplicados)
```

## 3. üîç EDA (An√°lisis Exploratorio)

### 3.1. Resumen Estad√≠stico
```python
# describe() de variables num√©ricas
# value_counts() de categ√≥ricas
```

### 3.2. Distribuciones Clave
```python
# Histogramas: Total, Quantity, Gross income
# Boxplots: Total por Branch/City
```

### 3.3. Correlaciones Iniciales
```python
# Matriz de correlaci√≥n (Total, Quantity, Gross margin %)
```

## 4. üï∞Ô∏è An√°lisis Temporales

### 4.1. Patrones Horarios
```python
# Heatmap hora vs d√≠a (nuestro an√°lisis inicial)
# Picos por tipo de cliente
```

### 4.2. Tendencia Semanal/Mensual
```python
# Ventas por d√≠a de semana
# Cohortes (retention rate)
```

## 5. üë• Segmentaci√≥n

### 5.1. Por Tipo de Cliente
```python
# Member vs Normal (ticket, frecuencia)
```

### 5.2. Por G√©nero
```python
# M√©todos de pago (Chi-cuadrado)
# Productos preferidos
```

## 6. üì¶ An√°lisis de Productos

### 6.1. Performance
```python
# Margen bruto por l√≠nea
# Outliers de rentabilidad
```

### 6.2. Asociaciones
```python
# Market Basket Analysis (combinaciones frecuentes)
```

## 7. üåç Geogr√°fico

### 7.1. Por Sucursal
```python
# Ventas totales, ticket promedio
```

### 7.2. Por Ciudad
```python
# Diferencias en preferencias
```

## 8. üî¨ Validaci√≥n Estad√≠stica
```python
# Tests de hip√≥tesis (t-test, chi2)
```

## 9. üìä Visualizaci√≥n
```python
# Exportar gr√°ficos clave (PNG/HTML)
```

## 10. üìù Conclusiones
```markdown
### Insights Principales:
1. "Pico de ventas a las 14:00 (25% sobre promedio)"
2. "Members gastan 12% m√°s pero misma frecuencia"
3. "Electr√≥nicos con mayor margen (28.5%)"

### Recomendaciones:
- Promociones horarias en picos
- Bundles para productos frecuentemente combinados
```
```












```markdown
# üõí Supermarket Sales - An√°lisis Estad√≠stico Completo

## 1. ‚öôÔ∏è Configuraci√≥n 
```python
# Librer√≠as (pandas, duckdb, seaborn, scipy)
```

## 2. üìÇ Datos
```python
# Carga y limpieza inicial
```

## 3. üìä An√°lisis Descriptivo (EDA+)

### 3.1. Estad√≠sticos B√°sicos
```python
# describe() + skew(), kurtosis()
# value_counts() normalizados
```

### 3.2. Visualizaci√≥n Univariada
```python
# Distribuciones (histogramas + boxplots)
# Diagramas de barras para categ√≥ricas
```

### 3.3. Visualizaci√≥n Multivariada
```python
# Matriz de correlaci√≥n
# Pairplots selectivos
```

## 4. üîé An√°lisis Inferencial

### 4.1. Comparaci√≥n de Grupos
```python
# t-test: Member vs Normal (Total)
# ANOVA: Rating vs Ticket promedio
```

### 4.2. Asociaci√≥n entre Variables
```python
# Chi-cuadrado: G√©nero vs Payment
# Correlaci√≥n de Spearman: Rating vs Frecuencia
```

### 4.3. Modelos Sencillos
```python
# Regresi√≥n lineal: Total ~ Quantity + Product line
```

## 5. üï∞Ô∏è An√°lisis Temporales
```python
# (Heatmaps, tendencias, cohortes)
```

## 6. üë• Segmentaci√≥n Avanzada
```python
# (RFM proxy, clustering b√°sico)
```

## 7. üìù Reporte Estad√≠stico
```python
# Tablas resumen con:
# - p-values
# - Tama√±os de efecto
# - Intervalos de confianza
```
```
















news_columns = {
    'Invoice ID': 'invoice_id',
    'Branch': 'branch',
    'City': 'city',
    'Customer type': 'customer_type',
    'Gender': 'gender',
    'Product line': 'product_line',
    'Unit price': 'unit_price',
    'Quantity': 'quantity',
    'Tax 5%': 'tax_5_percent',
    'Total': 'total',
    'Date': 'date',
    'Time': 'time',
    'Payment': 'payment_method',
    'Cost of goods sold': 'cost_of_goods_sold',
    'Gross margin percentage': 'gross_margin_percentage',
    'Gross income': 'gross_income',
    'Customer stratification rating': 'customer_rating'
}
df = df.rename(columns=news_columns)

Invoice ID ‚Üí ID de Factura
Branch ‚Üí Sucursal
City ‚Üí Ciudad
Customer type ‚Üí Tipo de Cliente
Gender ‚Üí G√©nero
Product line ‚Üí L√≠nea de Producto
Unit price ‚Üí Precio Unitario
Quantity ‚Üí Cantidad
Tax 5% ‚Üí Impuesto 5%
Total ‚Üí Total
Date ‚Üí Fecha
Time ‚Üí Hora
Payment ‚Üí M√©todo de Pago
Cost of goods sold ‚Üí Costo de Bienes Vendidos
Gross margin percentage ‚Üí Porcentaje de Margen Bruto
Gross income ‚Üí Ingreso Bruto
Customer stratification rating ‚Üí Calificaci√≥n de Estratificaci√≥n del Cliente





margin_query = """
SELECT
    "Product line",
    SUM("Total") AS Revenue,
    SUM("Cost of goods sold") AS Cost,
    SUM("Total" - "Cost of goods sold") AS Profit,
    ROUND((SUM("Total" - "Cost of goods sold") / SUM("Total")) * 100, 2) AS Profit_Margin_Percent
FROM df
GROUP BY "Product line"
ORDER BY Profit_Margin_Percent DESC
"""
margin_result = con.execute(margin_query).fetchdf()
margin_result


margen_query = """
SELECT 
    "Product line",
    AVG("Gross margin percentage") AS margen_promedio,
    SUM("Gross income") AS ingreso_bruto_total,
    COUNT(*) AS transacciones,
    AVG("Total") AS ticket_promedio
FROM df
GROUP BY "Product line"
ORDER BY ingreso_bruto_total DESC
"""
margen_data = duckdb.execute(margen_query).fetchdf()
margen_data



# Consulta para an√°lisis de m√°rgenes
margen_query = """
SELECT 
    "Product line",
    SUM("Total") AS Revenue,
    SUM("Cost of goods sold") AS Cost,
    SUM("Gross income") AS ingreso_bruto_total,
    COUNT(*) AS transacciones,
    AVG("Total") AS ticket_promedio,
    AVG("Gross margin percentage") AS margen_promedio,
    SUM("Total" - "Cost of goods sold") AS Profit,
    ROUND((SUM("Total" - "Cost of goods sold") / SUM("Total")) * 100, 2) AS Profit_Margin_Percent
FROM df
GROUP BY "Product line"
ORDER BY ingreso_bruto_total DESC
"""
margen_data = duckdb.execute(margen_query).fetchdf()
margen_data







# Configuraci√≥n visual
#plt.style.use('seaborn')
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Gr√°fico 1: Margen vs Ingreso bruto
scatter = sns.scatterplot(
    data=margen_data,
    x="margen_promedio",
    y="ingreso_bruto_total",
    hue="Product line",
    size="transacciones",
    sizes=(100, 500),
    palette="viridis",
    ax=ax1
)
ax1.set_title('Margen Bruto vs Ingreso por L√≠nea de Producto')
ax1.set_xlabel('Margen Promedio (%)')
ax1.set_ylabel('Ingreso Bruto Total ($)')
ax1.grid(True, linestyle='--', alpha=0.6)

# Gr√°fico 2: Distribuci√≥n de m√°rgenes
boxplot = sns.boxplot(
    data=margen_data,
    y="margen_promedio",
    x=0,  # Truco para boxplot horizontal
    width=0.4,
    palette="pastel",
    ax=ax2
)
ax2.set_title('Distribuci√≥n de M√°rgenes por Producto')
ax2.set_xlabel('')
ax2.set_ylabel('Margen Promedio (%)')
ax2.grid(True, linestyle='--', alpha=0.6)
ax2.get_xaxis().set_visible(False)  # Ocultar eje x innecesario

# Detecci√≥n de outliers estad√≠sticos
Q1 = margen_data["margen_promedio"].quantile(0.25)
Q3 = margen_data["margen_promedio"].quantile(0.75)
IQR = Q3 - Q1
outliers = margen_data[
    (margen_data["margen_promedio"] < (Q1 - 1.5 * IQR)) | 
    (margen_data["margen_promedio"] > (Q3 + 1.5 * IQR))
]

# Resaltar outliers en el gr√°fico
for idx, row in outliers.iterrows():
    ax1.annotate(
        row["Product line"],
        (row["margen_promedio"], row["ingreso_bruto_total"]),
        xytext=(10, 10),
        textcoords='offset points',
        bbox=dict(boxstyle='round,pad=0.5', fc='red', alpha=0.3)
    )

plt.tight_layout()
plt.show()





